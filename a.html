<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>星际沙盒 Pro - 矢量物理模拟</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        .ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        .glass { background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); }
        #permission-overlay {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;
        }
    </style>
</head>
<body>

    <div id="permission-overlay">
        <div class="mb-6 text-center">
            <div class="text-5xl mb-4">⏳</div>
            <h1 class="text-2xl font-bold">星际沙盒 Pro</h1>
            <p class="text-gray-400 mt-2">支持矢量重力与高频震动反馈</p>
        </div>
        <button id="start-btn" class="bg-indigo-600 px-10 py-4 rounded-full font-bold shadow-2xl active:scale-95 transition-transform">
            激活重力引擎
        </button>
    </div>

    <div class="ui-layer flex flex-col justify-between p-6">
        <div class="flex justify-between items-start">
            <div class="glass p-3 rounded-2xl text-white">
                <div id="planet-name" class="text-lg font-bold">地球</div>
                <div id="gravity-val" class="text-xs opacity-60 font-mono">G: 9.8 m/s²</div>
            </div>
            <button id="clear-btn" class="interactive glass w-12 h-12 rounded-full flex items-center justify-center text-white">✕</button>
        </div>

        <div class="interactive glass p-4 rounded-3xl">
            <div class="flex gap-2">
                <button class="planet-btn flex-1 py-3 rounded-xl text-white text-xs font-medium bg-white/5 active:bg-white/20" data-g="1.6" data-n="月球">月球</button>
                <button class="planet-btn flex-1 py-3 rounded-xl text-white text-xs font-medium bg-white/20" data-g="9.8" data-n="地球">地球</button>
                <button class="planet-btn flex-1 py-3 rounded-xl text-white text-xs font-medium bg-white/5" data-g="3.7" data-n="火星">火星</button>
                <button class="planet-btn flex-1 py-3 rounded-xl text-white text-xs font-medium bg-white/5" data-g="24.8" data-n="木星">木星</button>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('permission-overlay');
        const startBtn = document.getElementById('start-btn');
        
        // 物理常数
        let particles = [];
        const MAX_PARTICLES = 800;
        const PARTICLE_RADIUS = 3;
        const FRICTION = 0.98; // 摩擦力
        const BOUNCE = -0.3;   // 反弹系数
        let gravityVec = { x: 0, y: 0.5 };
        let gMagnitude = 0.5; // 当前重力强度映射
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.color = color;
            }

            update() {
                // 应用加速度（重力）
                this.vx += gravityVec.x * gMagnitude;
                this.vy += gravityVec.y * gMagnitude;

                // 应用速度
                this.x += this.vx;
                this.y += this.vy;

                // 应用摩擦力
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                // 边界碰撞检测
                let hitWall = false;
                if (this.x + PARTICLE_RADIUS > canvas.width) {
                    this.x = canvas.width - PARTICLE_RADIUS;
                    this.vx *= BOUNCE;
                    hitWall = true;
                } else if (this.x - PARTICLE_RADIUS < 0) {
                    this.x = PARTICLE_RADIUS;
                    this.vx *= BOUNCE;
                    hitWall = true;
                }

                if (this.y + PARTICLE_RADIUS > canvas.height) {
                    this.y = canvas.height - PARTICLE_RADIUS;
                    this.vy *= BOUNCE;
                    hitWall = true;
                } else if (this.y - PARTICLE_RADIUS < 0) {
                    this.y = PARTICLE_RADIUS;
                    this.vy *= BOUNCE;
                    hitWall = true;
                }

                // 震动逻辑：如果撞击速度够快，触发微震
                if (hitWall && (Math.abs(this.vx) > 5 || Math.abs(this.vy) > 5)) {
                    triggerVibration(10);
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, PARTICLE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        let lastVibe = 0;
        function triggerVibration(ms) {
            const now = Date.now();
            if (now - lastVibe > 100) { // 限制震动频率
                if (navigator.vibrate) {
                    navigator.vibrate(ms);
                    lastVibe = now;
                }
            }
        }

        function spawnParticles(x, y) {
            if (particles.length < MAX_PARTICLES) {
                const hue = (Date.now() / 10) % 360;
                particles.push(new Particle(x, y, `hsl(${hue}, 80%, 60%)`));
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(5, 5, 5, 0.4)'; // 拖尾效果
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        // 传感器处理
        function handleOrientation(e) {
            // 将角度转为弧度矢量
            // beta: 前后 (-180 to 180) -> y
            // gamma: 左右 (-90 to 90) -> x
            const b = e.beta * (Math.PI / 180);
            const g = e.gamma * (Math.PI / 180);

            // 真实的数学映射：计算手机在空间的倾斜投影
            gravityVec.x = Math.sin(g);
            gravityVec.y = Math.sin(b);
        }

        // UI 交互
        startBtn.onclick = async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const res = await DeviceOrientationEvent.requestPermission();
                if (res === 'granted') window.addEventListener('deviceorientation', handleOrientation);
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }
            
            overlay.style.display = 'none';
            triggerVibration([30, 50, 30]);
            animate();
        };

        document.querySelectorAll('.planet-btn').forEach(btn => {
            btn.onclick = () => {
                const g = parseFloat(btn.dataset.g);
                const n = btn.dataset.n;
                gMagnitude = g / 15; // 映射缩放
                document.getElementById('planet-name').innerText = n;
                document.getElementById('gravity-val').innerText = `G: ${g} m/s²`;
                
                document.querySelectorAll('.planet-btn').forEach(b => b.style.background = 'rgba(255,255,255,0.05)');
                btn.style.background = 'rgba(255,255,255,0.2)';
                triggerVibration(20);
            };
        });

        document.getElementById('clear-btn').onclick = () => {
            particles = [];
            triggerVibration(15);
        };

        // 触摸产生沙子
        let isDrawing = false;
        canvas.addEventListener('touchstart', (e) => { isDrawing = true; spawn(e); });
        canvas.addEventListener('touchmove', (e) => { if(isDrawing) spawn(e); });
        canvas.addEventListener('touchend', () => isDrawing = false);

        function spawn(e) {
            const touch = e.touches[0];
            for(let i=0; i<3; i++) {
                spawnParticles(touch.clientX + (Math.random()-0.5)*20, touch.clientY + (Math.random()-0.5)*20);
            }
        }

        window.onresize = init;
        init();

    </script>
</body>
</html>

